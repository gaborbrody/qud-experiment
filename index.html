<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Language Comprehension Study</title>
<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", sans-serif;
        background: #fff;
        color: #1a1a1a;
        line-height: 1.6;
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: flex-start;
        padding: 40px 20px;
    }

    #experiment-container {
        max-width: 740px;
        width: 100%;
        margin-top: 20px;
    }

    .screen { display: none; }
    .screen.active { display: block; }

    h2 {
        font-size: 1.4rem;
        font-weight: 600;
        margin-bottom: 1.2em;
        color: #111;
    }

    p { margin-bottom: 1em; color: #333; font-size: 0.95rem; }

    .consent-text {
        font-size: 0.9rem;
        line-height: 1.7;
        color: #444;
    }

    .consent-text p { margin-bottom: 0.8em; }

    .framing-phrase { font-weight: bold; }

    .btn {
        display: inline-block;
        padding: 10px 28px;
        font-size: 0.95rem;
        font-weight: 500;
        color: #fff;
        background: #222;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background 0.15s;
    }

    .btn:hover { background: #444; }
    .btn:disabled { background: #aaa; cursor: not-allowed; }

    .progress {
        font-size: 0.8rem;
        color: #999;
        margin-bottom: 16px;
    }

    .prompt {
        font-weight: 600;
        font-size: 0.95rem;
        margin-bottom: 18px;
        color: #111;
    }

    /* ===== Matching Task Styles ===== */

    .matching-area {
        display: flex;
        gap: 28px;
        margin-bottom: 28px;
    }

    .questions-column, .answers-column {
        flex: 1;
    }

    .column-header {
        font-size: 0.8rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: #888;
        margin-bottom: 10px;
    }

    .question-card {
        background: #f8f8f8;
        border: 2px solid #e0e0e0;
        border-radius: 6px;
        padding: 14px 16px;
        margin-bottom: 12px;
        font-size: 0.9rem;
        line-height: 1.6;
        color: #222;
        min-height: 80px;
        transition: border-color 0.2s, box-shadow 0.2s;
    }

    .question-card.drop-hover {
        border-color: #666;
        box-shadow: 0 0 0 2px rgba(0,0,0,0.08);
    }

    .question-card .label-tag {
        display: inline-block;
        font-size: 0.7rem;
        font-weight: 600;
        color: #999;
        background: #eee;
        padding: 2px 6px;
        border-radius: 3px;
        margin-bottom: 6px;
    }

    .drop-zone {
        min-height: 44px;
        border: 2px dashed #ccc;
        border-radius: 5px;
        margin-top: 10px;
        padding: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: border-color 0.2s, background 0.2s;
    }

    .drop-zone.empty {
        color: #bbb;
        font-size: 0.8rem;
    }

    .drop-zone.drop-hover {
        border-color: #666;
        background: #f0f0f0;
    }

    .drop-zone.filled {
        border-style: solid;
        border-color: #999;
        background: #fff;
    }

    .answer-pill {
        display: inline-block;
        background: #222;
        color: #fff;
        padding: 8px 14px;
        border-radius: 5px;
        font-size: 0.88rem;
        cursor: grab;
        user-select: none;
        transition: opacity 0.15s, transform 0.1s;
        line-height: 1.4;
        max-width: 100%;
    }

    .answer-pill:active {
        cursor: grabbing;
        transform: scale(1.03);
    }

    .answer-pill.dragging {
        opacity: 0.4;
    }

    .answer-pill.in-dropzone {
        cursor: grab;
        font-size: 0.85rem;
        background: #333;
    }

    .answers-pool {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-height: 100px;
        padding: 10px;
        background: #fafafa;
        border: 1px solid #eee;
        border-radius: 6px;
    }

    .answers-pool.empty-pool {
        align-items: center;
        justify-content: center;
        color: #ccc;
        font-size: 0.8rem;
    }

    .thank-you-text {
        font-size: 1.05rem;
        line-height: 1.7;
        color: #333;
    }

    .completion-code {
        margin-top: 20px;
        padding: 12px 16px;
        background: #f8f8f8;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        font-family: monospace;
        font-size: 1.1rem;
        text-align: center;
        letter-spacing: 1px;
    }

    .prolific-input {
        width: 100%;
        padding: 10px 14px;
        font-size: 0.95rem;
        border: 2px solid #e0e0e0;
        border-radius: 5px;
        margin-bottom: 16px;
        font-family: inherit;
        transition: border-color 0.15s;
    }

    .prolific-input:focus {
        outline: none;
        border-color: #666;
    }

    .prolific-label {
        font-size: 0.9rem;
        font-weight: 500;
        color: #333;
        margin-bottom: 6px;
        display: block;
    }

    .prolific-return {
        display: inline-block;
        margin-top: 20px;
        padding: 12px 28px;
        font-size: 0.95rem;
        font-weight: 500;
        color: #fff;
        background: #222;
        border: none;
        border-radius: 5px;
        text-decoration: none;
        transition: background 0.15s;
    }

    .prolific-return:hover { background: #444; }

    .touch-dragging {
        position: fixed;
        z-index: 1000;
        pointer-events: none;
        opacity: 0.9;
        transform: scale(1.05);
    }

    @media (max-width: 600px) {
        .matching-area {
            flex-direction: column;
            gap: 20px;
        }
    }
</style>
</head>
<body>
<div id="experiment-container">

    <!-- ==================== CONSENT ==================== -->
    <div id="consent-screen" class="screen active">
        <h2>Consent Statement</h2>
        <div class="consent-text">
            <p>Consent statement: By answering the following questions, you are consenting to participate in a research study being performed by Dr. Gabor Brody, PhD, at Yale University. (<a href="mailto:gabor.brody@yale.edu">gabor.brody@yale.edu</a>).</p>
            <p>In this research, you will: see or hear written short stories, sentences or words, videos and/or images. You will be asked to choose between two or more alternatives or give ratings using a keyboard or mouse.</p>
            <p>If you have questions about the research, please contact <a href="mailto:gabor.brody@yale.edu">gabor.brody@yale.edu</a>. Participation in this research is voluntary. You may decline to answer any or all of the following questions. You may decline further participation at any time without adverse consequences. Your anonymity is assured; the researchers who have requested your participation will not receive any personal information about you, and all data will be coded with subject numbers separate from your Mturk/Prolific/Testable ID. Anonymized data may be shared with collaborating universities.</p>
            <p><strong>I have read and understood the consent statement. I am at least 18 years of age.</strong></p>
        </div>
        <button class="btn" onclick="showInstructions()">I consent</button>
    </div>

    <!-- ==================== PROLIFIC ID ==================== -->
    <div id="prolific-screen" class="screen">
        <h2>Participant ID</h2>
        <p>Please confirm your Prolific ID below. It should be filled in automatically — if not, please enter it manually.</p>
        <label class="prolific-label" for="prolific-id-input">Prolific ID</label>
        <input type="text" id="prolific-id-input" class="prolific-input" placeholder="Enter your Prolific ID">
        <button class="btn" id="prolific-continue-btn" onclick="saveProlificId()" disabled>Continue</button>
    </div>

    <!-- ==================== INSTRUCTIONS ==================== -->
    <div id="instructions-screen" class="screen">
        <h2>Instructions</h2>
        <p>In this study, you will see pairs of questions asked by different people, along with two possible answers.</p>
        <p>Your task is to <strong>match each answer to the question it goes best with</strong> by dragging the answer into the box below the question.</p>
        <p>In some cases, both answers might seem reasonable for both questions. When that happens, please go with whatever matching <strong>feels most natural</strong> to you.</p>
        <p>There are no right or wrong answers for many of the items — we are interested in your intuitions.</p>
        <p>The study takes approximately <strong>3–5 minutes</strong>.</p>
        <br>
        <button class="btn" onclick="startExperiment()">Start the experiment</button>
    </div>

    <!-- ==================== TRIAL ==================== -->
    <div id="trial-screen" class="screen">
        <div class="progress" id="progress-text"></div>
        <div class="prompt">Match each answer to the question it goes best with. <em>If both go with both,</em> match them according to which matches better!</div>
        <div class="matching-area" id="matching-area"></div>
        <button class="btn" id="next-btn" disabled onclick="submitTrial()">Next</button>
    </div>

    <!-- ==================== THANK YOU ==================== -->
    <div id="thankyou-screen" class="screen">
        <h2>Thank you!</h2>
        <div class="thank-you-text">
            <p>Your responses have been recorded. Please click the button below to return to Prolific and complete the study.</p>
        </div>
        <div class="completion-code" id="completion-code"></div>
        <br>
        <a id="prolific-return-link" class="prolific-return" href="#" target="_blank">Return to Prolific</a>
        <div id="github-save-report" role="status" aria-live="polite" style="margin-top: 18px; font-size: 1.4rem; text-align: center;">
            <span id="github-save-indicator"></span>
        </div>
    </div>

</div>

<script>
// =============================================================
// QUD Urgency Experiment 1 — Matching Task
// =============================================================
// 2 practice controls (always first: 1 timing, 1 morality)
// Then shuffled:
//   4 experimental items
//   2 timing controls
//   2 morality controls
// DV: which answer is matched to which question
// =============================================================

// =====================
// RELAY CONFIG — Fill these in before deploying
// =====================
// 1. Deploy Cloudflare Worker from cloudflare/worker.js
// 2. Set GH_TOKEN, GH_OWNER, GH_REPO, ALLOWED_ORIGIN in Worker environment
// 3. Set RELAY_ENDPOINT below (your Worker URL)
var RELAY_ENDPOINT = "https://qud-relay.gaborbrody.workers.dev";
var GITHUB_DATA_REPO = "gaborbrody/qud-experiment-data"; // display only

// Prolific return URL — replace XXXXXXX with your study's completion code
var PROLIFIC_RETURN_URL = "https://app.prolific.com/submissions/complete?cc=CU3CXT49";
// =====================
// STIMULI
// =====================

// --- PRACTICE ITEMS (always shown first, in this order) ---
var practiceItems = [
    {
        id: "practice_time",
        type: "practice_timing",
        scenario: "train_ticket",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Would it be possible to get a ticket for the next train?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Would it be possible to get a ticket for the next train?'
        },
        answer_a: { key: "immediate", text: "Let me check right away." },
        answer_b: { key: "delayed", text: "You could, but let me tell you some better options." },
        correct_mapping: { "urgent": "immediate", "not_urgent": "delayed" }
    },
    {
        id: "practice_moral",
        type: "practice_morality",
        scenario: "umbrella",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Would it be possible to borrow an umbrella from the lost and found?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Would it be possible to take someone\'s lunch from the fridge?'
        },
        answer_a: { key: "innocent", text: "Yes, just bring it back tomorrow." },
        answer_b: { key: "moral", text: "No, that wouldn\'t be nice." },
        correct_mapping: { "borrow": "innocent", "take": "moral" }
    }
];

// --- MAIN ITEMS (shuffled) ---
var mainItems = [
    // --- EXPERIMENTAL ITEMS ---
    {
        id: "exp_1",
        type: "experimental",
        scenario: "stealing_register",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Would it be possible to get away with taking some money from the cash register?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Would it be possible to get away with taking some money from the cash register?'
        },
        answer_a: { key: "no", text: "No, it would be really slimy." },
        answer_b: { key: "yes", text: "Yes, but it would be really slimy." }
    },
    {
        id: "exp_2",
        type: "experimental",
        scenario: "stealing_whisky",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Would it be possible to take a bottle of whisky while the bartender is not looking?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Would it be possible to take a bottle of whisky while the bartender is not looking?'
        },
        answer_a: { key: "no", text: "No, it would be stealing and I come here all the time." },
        answer_b: { key: "yes", text: "Yes, but it would be stealing and I come here all the time." }
    },
    {
        id: "exp_3",
        type: "experimental",
        scenario: "hacking_computer",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Would it be possible to hack into the professor\'s computer before the exam starts?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Would it be possible to hack into the professor\'s computer before the exam starts?'
        },
        answer_a: { key: "no", text: "No, it would be completely illegal." },
        answer_b: { key: "yes", text: "Yes, but it would be completely illegal." }
    },
    {
        id: "exp_4",
        type: "experimental",
        scenario: "forging_signature",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Would it be possible for you to forge my mom\'s signature on this report card?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Would it be possible for you to forge my mom\'s signature on this report card?'
        },
        answer_a: { key: "no", text: "No, it just wouldn\'t be right." },
        answer_b: { key: "yes", text: "Yes, but it just wouldn\'t be right." }
    },

    // --- TIMING CONTROLS ---
    {
        id: "ctrl_time_1",
        type: "control_timing",
        scenario: "car_transmission",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Would it be possible to order a new transmission for my car?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Would it be possible to order a new transmission for my car?'
        },
        answer_a: { key: "immediate", text: "I\'m going to check it immediately." },
        answer_b: { key: "delayed", text: "Sure, I\u2019ll get back to you tomorrow." },
        correct_mapping: { "urgent": "immediate", "not_urgent": "delayed" }
    },
    {
        id: "ctrl_time_2",
        type: "control_timing",
        scenario: "basement_plumber",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Is it possible to get a plumber to take a look at our basement?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Is it possible to get a plumber to take a look at our basement?'
        },
        answer_a: { key: "immediate", text: "Let me make some calls right now." },
        answer_b: { key: "delayed", text: "I\u2019ll look into it when I get a chance." },
        correct_mapping: { "urgent": "immediate", "not_urgent": "delayed" }
    },

    // --- MORALITY CONTROLS ---
    {
        id: "ctrl_moral_1",
        type: "control_morality",
        scenario: "pen",
        question_a: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Is it possible to borrow a pen from the front desk?'
        },
        question_b: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Is it possible to take someone\'s pen without them noticing?'
        },
        answer_a: { key: "innocent", text: "Yes, they usually have extras." },
        answer_b: { key: "moral", text: "No, that would be wrong." },
        correct_mapping: { "borrow": "innocent", "take": "moral" }
    },
    {
        id: "ctrl_moral_2",
        type: "control_morality",
        scenario: "neighbor",
        question_a: {
            urgency: "not_urgent",
            text: '<span class="framing-phrase">Just wondering...</span> Is it possible to ask the neighbor to turn down the music?'
        },
        question_b: {
            urgency: "urgent",
            text: '<span class="framing-phrase">Quickly!</span> Is it possible to slash the neighbor\'s tires so they can\'t go to the party?'
        },
        answer_a: { key: "innocent", text: "Yes, just knock on their door." },
        answer_b: { key: "moral", text: "No, that would be terrible." },
        correct_mapping: { "ask": "innocent", "slash": "moral" }
    }
];

// =====================
// STATE
// =====================

var participantId = generateUUID();
var prolificId = "";
var trials = [];
var currentTrialIndex = 0;
var trialData = [];
var trialStartTime = 0;

var draggedEl = null;
var dragSourceZone = null;

function getRelayEndpoint() {
    return (RELAY_ENDPOINT || "").trim();
}

// =====================
// SETUP
// =====================

function setupTrials() {
    // Practice items first (in fixed order), then shuffled main items
    trials = practiceItems.slice().concat(shuffleArray(mainItems.slice()));
}

// =====================
// DISPLAY
// =====================

function showScreen(id) {
    document.querySelectorAll('.screen').forEach(function(s) {
        s.classList.remove('active');
    });
    document.getElementById(id).classList.add('active');
    window.scrollTo(0, 0);
}

function showProlificScreen() {
    showScreen('prolific-screen');
    // Auto-fill Prolific ID from URL parameter
    var urlParams = new URLSearchParams(window.location.search);
    var pid = urlParams.get('PROLIFIC_PID') || '';
    var input = document.getElementById('prolific-id-input');
    if (pid) {
        input.value = pid;
        document.getElementById('prolific-continue-btn').disabled = false;
    }
    input.addEventListener('input', function() {
        document.getElementById('prolific-continue-btn').disabled = !this.value.trim();
    });
}

function saveProlificId() {
    prolificId = document.getElementById('prolific-id-input').value.trim();
    if (!prolificId) return;
    showScreen('instructions-screen');
}

function showInstructions() {
    showProlificScreen();
}

function startExperiment() {
    setupTrials();
    currentTrialIndex = 0;
    showTrial();
}

function showTrial() {
    if (currentTrialIndex >= trials.length) {
        finishExperiment();
        return;
    }

    showScreen('trial-screen');

    var trial = trials[currentTrialIndex];

    document.getElementById('progress-text').textContent =
        "Question " + (currentTrialIndex + 1) + " of " + trials.length;

    // Randomize question order (top/bottom)
    var qOrder = Math.random() < 0.5 ? ["a", "b"] : ["b", "a"];
    // Randomize answer order in pool
    var aOrder = Math.random() < 0.5 ? ["a", "b"] : ["b", "a"];

    trial._qOrder = qOrder;
    trial._aOrder = aOrder;

    var q1 = trial["question_" + qOrder[0]];
    var q2 = trial["question_" + qOrder[1]];
    var a1 = trial["answer_" + aOrder[0]];
    var a2 = trial["answer_" + aOrder[1]];

    var html =
        '<div class="questions-column">' +
            '<div class="column-header">Questions</div>' +
            '<div class="question-card" id="qcard-0">' +
                '<div class="label-tag">Question 1</div>' +
                '<div>' + q1.text + '</div>' +
                '<div class="drop-zone empty" id="drop-0" data-q-index="0" data-q-key="' + qOrder[0] + '">' +
                    'drag answer here' +
                '</div>' +
            '</div>' +
            '<div class="question-card" id="qcard-1">' +
                '<div class="label-tag">Question 2</div>' +
                '<div>' + q2.text + '</div>' +
                '<div class="drop-zone empty" id="drop-1" data-q-index="1" data-q-key="' + qOrder[1] + '">' +
                    'drag answer here' +
                '</div>' +
            '</div>' +
        '</div>' +
        '<div class="answers-column">' +
            '<div class="column-header">Answers</div>' +
            '<div class="answers-pool" id="answers-pool">' +
                '<div class="answer-pill" draggable="true" id="pill-0" data-a-key="' + aOrder[0] + '">' + a1.text + '</div>' +
                '<div class="answer-pill" draggable="true" id="pill-1" data-a-key="' + aOrder[1] + '">' + a2.text + '</div>' +
            '</div>' +
        '</div>';

    document.getElementById('matching-area').innerHTML = html;
    document.getElementById('next-btn').disabled = true;

    setupDragAndDrop();

    trialStartTime = Date.now();
}

// =====================
// DRAG AND DROP
// =====================

function setupDragAndDrop() {
    var pills = document.querySelectorAll('.answer-pill');
    var dropZones = document.querySelectorAll('.drop-zone');
    var pool = document.getElementById('answers-pool');

    pills.forEach(function(pill) {
        pill.addEventListener('dragstart', function(e) {
            draggedEl = this;
            dragSourceZone = this.parentElement;
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', this.id);
        });

        pill.addEventListener('dragend', function(e) {
            this.classList.remove('dragging');
            draggedEl = null;
            dragSourceZone = null;
            clearHovers();
        });

        pill.addEventListener('touchstart', function(e) {
            e.preventDefault();
            draggedEl = this;
            dragSourceZone = this.parentElement;
            startTouchDrag(e, this);
        });
    });

    dropZones.forEach(function(zone) {
        zone.addEventListener('dragover', function(e) {
            e.preventDefault();
            this.classList.add('drop-hover');
        });

        zone.addEventListener('dragleave', function(e) {
            this.classList.remove('drop-hover');
        });

        zone.addEventListener('drop', function(e) {
            e.preventDefault();
            this.classList.remove('drop-hover');
            handleDrop(this);
        });
    });

    pool.addEventListener('dragover', function(e) {
        e.preventDefault();
    });

    pool.addEventListener('drop', function(e) {
        e.preventDefault();
        if (draggedEl) {
            pool.appendChild(draggedEl);
            draggedEl.classList.remove('in-dropzone');
            if (dragSourceZone && dragSourceZone.classList.contains('drop-zone')) {
                dragSourceZone.classList.add('empty');
                dragSourceZone.classList.remove('filled');
                dragSourceZone.textContent = 'drag answer here';
            }
            checkCompletion();
        }
    });
}

function handleDrop(zone) {
    if (!draggedEl) return;

    var existingPill = zone.querySelector('.answer-pill');
    if (existingPill) {
        if (dragSourceZone && dragSourceZone.classList.contains('drop-zone')) {
            dragSourceZone.textContent = '';
            dragSourceZone.appendChild(existingPill);
            dragSourceZone.classList.remove('empty');
            dragSourceZone.classList.add('filled');
        } else {
            document.getElementById('answers-pool').appendChild(existingPill);
            existingPill.classList.remove('in-dropzone');
        }
    } else {
        if (dragSourceZone && dragSourceZone.classList.contains('drop-zone')) {
            dragSourceZone.classList.add('empty');
            dragSourceZone.classList.remove('filled');
            dragSourceZone.textContent = 'drag answer here';
        }
    }

    zone.textContent = '';
    zone.appendChild(draggedEl);
    draggedEl.classList.remove('dragging');
    draggedEl.classList.add('in-dropzone');
    zone.classList.remove('empty');
    zone.classList.add('filled');

    checkCompletion();
}

function clearHovers() {
    document.querySelectorAll('.drop-hover').forEach(function(el) {
        el.classList.remove('drop-hover');
    });
}

function checkCompletion() {
    var drop0 = document.getElementById('drop-0');
    var drop1 = document.getElementById('drop-1');
    var filled0 = drop0.querySelector('.answer-pill');
    var filled1 = drop1.querySelector('.answer-pill');
    document.getElementById('next-btn').disabled = !(filled0 && filled1);
}

// =====================
// TOUCH SUPPORT
// =====================

function startTouchDrag(e, pill) {
    var touch = e.touches[0];
    var clone = pill.cloneNode(true);
    clone.classList.add('touch-dragging');
    clone.style.width = pill.offsetWidth + 'px';
    clone.id = 'touch-clone';
    document.body.appendChild(clone);

    var offsetX = pill.offsetWidth / 2;
    var offsetY = pill.offsetHeight / 2;
    clone.style.left = (touch.clientX - offsetX) + 'px';
    clone.style.top = (touch.clientY - offsetY) + 'px';

    pill.classList.add('dragging');

    function onTouchMove(e2) {
        e2.preventDefault();
        var t = e2.touches[0];
        clone.style.left = (t.clientX - offsetX) + 'px';
        clone.style.top = (t.clientY - offsetY) + 'px';

        clone.style.display = 'none';
        var elBelow = document.elementFromPoint(t.clientX, t.clientY);
        clone.style.display = '';

        clearHovers();
        if (elBelow) {
            var zone = elBelow.closest('.drop-zone');
            if (zone) zone.classList.add('drop-hover');
        }
    }

    function onTouchEnd(e2) {
        var t = e2.changedTouches[0];
        clone.style.display = 'none';
        var elBelow = document.elementFromPoint(t.clientX, t.clientY);
        clone.style.display = '';

        document.body.removeChild(clone);
        pill.classList.remove('dragging');
        clearHovers();

        if (elBelow) {
            var zone = elBelow.closest('.drop-zone');
            var pool = elBelow.closest('.answers-pool');
            if (zone) {
                handleDrop(zone);
            } else if (pool) {
                pool.appendChild(pill);
                pill.classList.remove('in-dropzone');
                if (dragSourceZone && dragSourceZone.classList.contains('drop-zone')) {
                    dragSourceZone.classList.add('empty');
                    dragSourceZone.classList.remove('filled');
                    dragSourceZone.textContent = 'drag answer here';
                }
                checkCompletion();
            }
        }

        draggedEl = null;
        dragSourceZone = null;
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);
    }

    document.addEventListener('touchmove', onTouchMove, { passive: false });
    document.addEventListener('touchend', onTouchEnd);
}

// =====================
// SUBMIT TRIAL
// =====================

function submitTrial() {
    var trial = trials[currentTrialIndex];
    var rt = Date.now() - trialStartTime;

    var drop0pill = document.getElementById('drop-0').querySelector('.answer-pill');
    var drop1pill = document.getElementById('drop-1').querySelector('.answer-pill');

    var q0key = document.getElementById('drop-0').getAttribute('data-q-key');
    var q1key = document.getElementById('drop-1').getAttribute('data-q-key');

    var a0key = drop0pill.getAttribute('data-a-key');
    var a1key = drop1pill.getAttribute('data-a-key');

    var mapping = {};
    mapping[q0key] = a0key;
    mapping[q1key] = a1key;

    // For experimental items: did they match "no" (answer_a) with "urgent" (question_a)?
    var matchedNoWithUrgent = null;
    if (trial.type === "experimental") {
        matchedNoWithUrgent = (mapping["a"] === "a");
    }

    trialData.push({
        trial_number: currentTrialIndex + 1,
        item_id: trial.id,
        item_type: trial.type,
        scenario: trial.scenario,
        question_order: trial._qOrder.join("-"),
        answer_order: trial._aOrder.join("-"),
        answer_matched_to_q_a: mapping["a"],
        answer_matched_to_q_b: mapping["b"],
        matched_no_with_urgent: matchedNoWithUrgent,
        rt_ms: rt
    });

    currentTrialIndex++;
    showTrial();
}

// =====================
// FINISH & DATA
// =====================

function finishExperiment() {
    var completionCode = "CU3CXT49".toUpperCase();

    var fullData = {
        participant_id: participantId,
        prolific_id: prolificId,
        timestamp: new Date().toISOString(),
        user_agent: navigator.userAgent,
        trials: trialData
    };

    document.getElementById('completion-code').textContent = completionCode;

    // Set up Prolific return link
    document.getElementById('prolific-return-link').href = PROLIFIC_RETURN_URL;

    showScreen('thankyou-screen');

    // Save via server-side relay endpoint
    var relayEndpoint = getRelayEndpoint();
    if (relayEndpoint) {
        setGitHubSaveReport("pending", "Uploading response data to GitHub...", [
            "Repository: " + GITHUB_DATA_REPO,
            "Endpoint: " + relayEndpoint,
            "Mode: relay (server-side token)"
        ]);

        saveToRelay(fullData, completionCode, relayEndpoint).then(function(report) {
            renderGitHubSaveReport(report);
        });
    } else {
        setGitHubSaveReport("error", "GitHub upload is not configured.", [
            "Configuration issue detected:",
            "Missing RELAY_ENDPOINT.",
            "Set RELAY_ENDPOINT to your deployed Workers URL.",
            "Data is available only via local CSV download."
        ]);
        console.warn("Relay endpoint is not configured — data only available via local download.");
    }
}

function setGitHubSaveReport(statusType, summary, detailLines) {
    var indicator = document.getElementById('github-save-indicator');
    if (!indicator) return;

    if (statusType === "success") {
        indicator.textContent = "\u2705";
        indicator.title = "Data saved successfully";
    } else if (statusType === "error") {
        indicator.textContent = "\u274C";
        indicator.title = summary + " " + (detailLines || []).join(" ");
    } else {
        indicator.textContent = "\u23F3";
        indicator.title = "Uploading...";
    }
}

function inferRelayFailureReason(status, apiMessage) {
    var msg = (apiMessage || "").toLowerCase();

    if (status === 400) {
        return "Relay rejected payload as invalid.";
    }
    if (status === 401) {
        return "Relay could not authenticate with GitHub. Server token may be invalid.";
    }
    if (status === 403) {
        if (msg.indexOf("origin not allowed") !== -1) {
            return "Request origin is blocked by relay ALLOWED_ORIGIN.";
        }
        if (msg.indexOf("resource not accessible by personal access token") !== -1) {
            return "Server token lacks required access. Check repo scope and Issues permission.";
        }
        if (msg.indexOf("rate limit") !== -1) {
            return "GitHub API rate limit was exceeded.";
        }
        return "Request forbidden by relay or GitHub permissions.";
    }
    if (status === 404) {
        return "Relay endpoint or target repository was not found.";
    }
    if (status === 405) {
        return "Relay endpoint does not allow this HTTP method.";
    }
    if (status === 422) {
        if (msg.indexOf("spammed") !== -1 || msg.indexOf("abuse") !== -1) {
            return "GitHub flagged this request as spam/abuse. Retry later with less frequent submissions.";
        }
        return "Validation failed. Payload or labels may be invalid.";
    }
    if (status === 502) {
        return "Relay failed before it got a response from GitHub.";
    }
    if (status >= 500) {
        return "Relay server error. Check relay env vars and deployment logs.";
    }
    return "Unexpected API response.";
}

function renderGitHubSaveReport(report) {
    if (report.ok) {
        setGitHubSaveReport("success", "Data saved.", []);
        console.log("Data saved to GitHub issue.", report);
    } else {
        setGitHubSaveReport("error", "Data upload failed.", [report.likely_reason || ""]);
        console.error("GitHub save failed.", report);
    }
}

async function saveToRelay(data, completionCode, relayEndpoint) {
    // Format trial data as a readable table for the issue body
    var endpoint = relayEndpoint;
    var startedAt = new Date().toISOString();

    try {
        var resp = await fetch(endpoint, {
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                data: data,
                completionCode: completionCode
            })
        });

        var rawText = await resp.text();
        var payload = null;
        try {
            payload = rawText ? JSON.parse(rawText) : null;
        } catch (jsonErr) {
            payload = null;
        }

        var githubMessage = payload && (payload.error || payload.message)
            ? (payload.error || payload.message)
            : rawText;
        var requestId = resp.headers.get("x-github-request-id")
            || (payload && payload.github_request_id ? payload.github_request_id : "")
            || "";
        var relayVersion = resp.headers.get("x-relay-version")
            || (payload && payload.relay_version ? payload.relay_version : "")
            || "";
        var rateLimitRemaining = resp.headers.get("x-ratelimit-remaining") || "";

        if (!resp.ok) {
            return {
                ok: false,
                status: resp.status,
                repo: GITHUB_DATA_REPO,
                endpoint: endpoint,
                relay_version: relayVersion,
                request_id: requestId,
                rate_limit_remaining: rateLimitRemaining,
                started_at: startedAt,
                finished_at: new Date().toISOString(),
                likely_reason: inferRelayFailureReason(resp.status, githubMessage),
                github_message: githubMessage,
                github_errors: payload && (payload.github_errors || payload.errors)
                    ? JSON.stringify(payload.github_errors || payload.errors)
                    : "",
                documentation_url: payload && payload.documentation_url ? payload.documentation_url : ""
            };
        }

        return {
            ok: true,
            status: resp.status,
            repo: GITHUB_DATA_REPO,
            endpoint: endpoint,
            relay_version: relayVersion,
            request_id: requestId,
            rate_limit_remaining: rateLimitRemaining,
            started_at: startedAt,
            finished_at: new Date().toISOString(),
            issue_number: payload && payload.issue_number ? payload.issue_number : "n/a",
            issue_url: payload && payload.issue_url ? payload.issue_url : ""
        };
    } catch (err) {
        return {
            ok: false,
            status: 0,
            repo: GITHUB_DATA_REPO,
            endpoint: endpoint,
            relay_version: "",
            request_id: "",
            rate_limit_remaining: "",
            started_at: startedAt,
            finished_at: new Date().toISOString(),
            likely_reason: "Network/CORS error before relay response (Worker URL unreachable, origin blocked, or page closed).",
            github_message: err && err.message ? err.message : String(err),
            github_errors: "",
            documentation_url: ""
        };
    }
}

function downloadData() {
    // Fallback: download the current session's data as CSV
    if (trialData.length === 0) {
        alert("No data collected yet.");
        return;
    }

    var csvRows = [
        "participant_id,prolific_id,timestamp,trial_number,item_id,item_type,scenario,question_order,answer_order,answer_matched_to_q_a,answer_matched_to_q_b,matched_no_with_urgent,rt_ms"
    ];

    trialData.forEach(function(t) {
        csvRows.push([
            participantId,
            prolificId,
            new Date().toISOString(),
            t.trial_number,
            t.item_id,
            t.item_type,
            t.scenario,
            t.question_order,
            t.answer_order,
            t.answer_matched_to_q_a,
            t.answer_matched_to_q_b,
            t.matched_no_with_urgent === null ? "" : t.matched_no_with_urgent,
            t.rt_ms
        ].join(","));
    });

    var blob = new Blob([csvRows.join("\n")], {type: "text/csv"});
    var url = URL.createObjectURL(blob);
    var a = document.createElement("a");
    a.href = url;
    a.download = "qud_matching_exp1_data.csv";
    a.click();
    URL.revokeObjectURL(url);
}

// =====================
// UTILITIES
// =====================

function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0;
        var v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

function shuffleArray(arr) {
    var shuffled = arr.slice();
    for (var i = shuffled.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = shuffled[i];
        shuffled[i] = shuffled[j];
        shuffled[j] = temp;
    }
    return shuffled;
}
</script>
</body>
</html>
